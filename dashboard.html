<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NuroBot | Digital Twin</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="icon" href="favicon.jpeg" type="image/x-icon">
    <style>
        /* --- CSS STYLES --- */
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --primary: #00F0FF;
            --secondary: #7c3aed;
            --text: #e4e4e7;
            --border: #27272a;
            --danger: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body { 
            background: var(--bg); color: var(--text); 
            font-family: 'Segoe UI', sans-serif; overflow: hidden; 
            cursor: none;
        }

        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            transition: transform 0.1s ease;
            display: none;
        }

        /* Animation Control Panel */
        .animation-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--border);
            z-index: 100;
            backdrop-filter: blur(10px);
            width: 280px;
        }

        .animation-controls h4 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            display: block;
            color: #a1a1aa;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .select-control {
            width: 100%;
            background: rgba(0,0,0,0.6);
            border: 1px solid var(--border);
            color: white;
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
        }

        .animation-status {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .force-controls {
            background: rgba(16, 185, 129, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid var(--success);
        }

        .force-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 8px;
        }

        .force-btn {
            padding: 6px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,0.05);
            color: #a1a1aa;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .force-btn:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .force-btn.active {
            background: var(--primary);
            color: #000;
            border-color : var(--primary);
        }

        /* Material State Display */
        .material-state {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        .state-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
        }

        .state-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .state-text {
            font-size: 11px;
            color: #a1a1aa;
        }

        /* Navbar */
        .global-nav {
            background-color: rgba(22, 22, 23, 0.95); width: 100%; height: 50px;
            display: flex; justify-content: center; align-items: center; top: 0;
            font-size: 14px; position: sticky; z-index: 999;
            border-bottom: 1px solid var(--border);
        }
        .nav-content {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; max-width: 1080px; padding: 0 20px;
        }
        .list-item { list-style: none; cursor: pointer; }
        .list-item a {
            text-decoration: none; color: #a1a1aa; padding: 8px 12px;
            transition: all 0.2s; border-radius: 6px; font-weight: 500;
        }
        .list-item a:hover, .list-item a.active { color: #fff; background: rgba(255,255,255,0.1); }
        .brand { color: var(--primary) !important; font-weight: bold; letter-spacing: 1px; }

        /* Layout */
        .layout-grid {
            display: grid; grid-template-columns: 45% 55%; 
            height: calc(100vh - 50px); width: 100vw;
        }

        /* Left: 3D Stage */
        .robot-stage {
            position: relative;
            background: radial-gradient(circle at center, #27272a 0%, #09090b 100%);
            border-right: 1px solid var(--border);
            overflow: hidden;
        }
        #three-canvas-container { width: 100%; height: 100%; display: block; }
        
        .status-overlay {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 8px 16px; border-radius: 20px; 
            border: 1px solid #333; backdrop-filter: blur(5px); 
            font-family: monospace; font-size: 12px; display: flex; align-items: center; gap: 8px;
        }
        .health-score-overlay {
            position: absolute; bottom: 30px; right: 30px; text-align: right; pointer-events: none;
        }
        .health-number { font-size: 4rem; font-weight: bold; color: var(--primary); line-height: 1; text-shadow: 0 0 20px rgba(0,240,255,0.3); }
        .health-label { font-size: 0.8rem; color: #a1a1aa; letter-spacing: 2px; }

        /* Right: Dashboard Pages */
        .dashboard-content { 
            overflow-y: auto; padding: 40px; background: var(--bg); position: relative;
        }
        .page-section { display: none; animation: fadeIn 0.4s ease; }
        .page-section.active { display: block; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Typography & Cards */
        h1 { font-size: 2rem; margin-bottom: 10px; }
        h2 { font-size: 1.2rem; color: #a1a1aa; margin-bottom: 20px; font-weight: 400; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
        p { color: #a1a1aa; line-height: 1.6; margin-bottom: 20px; }

        .card-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 30px; }
        .card {
            background: var(--surface); border: 1px solid var(--border); 
            border-radius: 12px; padding: 20px; text-align: center;
        }
        .card .value { font-size: 2.2rem; font-weight: bold; color: #fff; margin: 10px 0; }
        
        /* Analytics Charts Grid */
        .charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .chart-box { background: var(--surface); padding: 15px; border-radius: 12px; border: 1px solid var(--border); }

        /* AI Box */
        .ai-panel {
            background: rgba(16, 185, 129, 0.05); border: 1px solid var(--success);
            border-radius: 12px; padding: 20px; margin-top: 20px;
        }
        .ai-list { list-style: none; margin-top: 10px; }
        .ai-list li { 
            padding: 10px; border-bottom: 1px solid rgba(255,255,255,0.05); 
            display: flex; gap: 10px; align-items: flex-start;
        }
        .ai-list li:last-child { border-bottom: none; }

        /* Profile Form */
        .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; color: #a1a1aa; margin-bottom: 5px; font-size: 0.9rem; }
        .input-group input { 
            width: 100%; background: #000; border: 1px solid var(--border); 
            color: #fff; padding: 10px; border-radius: 6px;
        }

        /* Button */
        .btn-connect {
            background: var(--primary); color: #000; border: none;
            padding: 10px 24px; border-radius: 30px; cursor: pointer; 
            font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
            transition: transform 0.2s; display: inline-block;
        }
        .btn-connect:hover { transform: scale(1.05); box-shadow: 0 0 15px var(--primary); }
        .disclaimer { font-size: 0.75rem; color: #666; margin-top: 8px; font-style: italic; }

        /* --- MOBILE RESPONSIVENESS --- */
        @media (max-width: 900px) {
            .layout-grid {
                grid-template-columns: 1fr;
                grid-template-rows: 45vh 1fr; 
                height: 100vh;
                overflow: hidden; 
            }

            .robot-stage {
                border-right: none;
                border-bottom: 1px solid var(--border);
                width: 100%;
            }

            .dashboard-content {
                padding: 20px;
                overflow-y: scroll;
                height: 100%;
                padding-bottom: 100px;
            }

            body { cursor: auto; }
            .custom-cursor { display: none !important; }
            .animation-controls { display: none !important; }

            .nav-content {
                padding: 0 15px;
                justify-content: flex-start;
                gap: 20px;
                overflow-x : auto;
                -webkit-overflow-scrolling: touch;
            }
            .nav-content::-webkit-scrollbar { display: none; }
            .list-item { white-space: nowrap; }

            .card-row { grid-template-columns: 1fr; gap: 15px; }
            .charts-grid { grid-template-columns: 1fr; }
            .form-grid { grid-template-columns: 1fr; }
            
            h1 { font-size: 1.5rem; }
            .health-number { font-size: 3rem; }
        }
    </style>
</head>

<body>
    <div class="custom-cursor" id="customCursor"></div>

    <!-- Animation Control Panel -->
    <div class="animation-controls">
        <h4><i class="fas fa-cog"></i> Robot Controls</h4>
        
        <div class="control-group">
            <label class="control-label">Animation Mode</label>
            <select class="select-control" id="animationMode">
                <option value="sensor">Sensor-Based (Health)</option>
                <option value="forced">Forced Animation</option>
            </select>
        </div>
        
        <div id="forcedControls" class="force-controls" style="display: none;">
            <label class="control-label">Force Animation</label>
            <div class="force-buttons">
                <button class="force-btn" data-anim="idle_healthy">Healthy</button>
                <button class="force-btn" data-anim="idle_stressed">Stressed</button>
                <button class="force-btn" data-anim="idle_critical">Critical</button>
                <button class="force-btn" data-anim="idle_alert">Alert</button>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Current Animation</label>
            <div class="animation-status" id="currentAnimationStatus">idle_healthy</div>
        </div>

        <div class="material-state">
            <label class="control-label">Material State</label>
            <div class="state-indicator">
                <div class="state-color" id="materialStateColor" style="background: #D4D4D4;"></div>
                <div class="state-text" id="materialStateText">Healthy (Silver)</div>
            </div>
        </div>
    </div>

    <nav class="global-nav">
        <ul class="nav-content">
            <li class="list-item" style="font-size: 21px;"><a href="#" class="brand">NuroTwin</a></li>
            <li class="list-item"><a href="#" onclick="navTo('dashboard')" class="active" id="nav-dashboard">Dashboard</a></li>
            <li class="list-item"><a href="#" onclick="navTo('bio')" id="nav-bio">Bio-Metrics</a></li>
            <li class="list-item"><a href="#" onclick="navTo('analytics')" id="nav-analytics">Analytics</a></li>
            <li class="list-item"><a href="#" onclick="navTo('ai')" id="nav-ai">AI Diagnostics</a></li>
            <li class="list-item"><a href="#" onclick="navTo('profile')" id="nav-profile">Profile</a></li>
        </ul>
    </nav>

    <div class="layout-grid">
        
        <div class="robot-stage">
            <div id="three-canvas-container"></div>
            
            <div class="status-overlay">
                <span id="hw-dot" style="width: 8px; height: 8px; background: #555; border-radius: 50%;"></span>
                <span id="hw-text" style="color: #888;">STANDBY</span>
            </div>

            <div class="health-score-overlay">
                <div class="health-number" id="val-health">--</div>
                <div class="health-label">HEALTH SCORE</div>
            </div>
        </div>

        <div class="dashboard-content">
            <div id="page-dashboard" class="page-section active">
                <h1>Cognitive Health Twin</h1>
                <p>Real-time digital interface monitoring physiological data via ESP32 sensors.</p>
                <button class="btn-connect" onclick="toggleDemoMode()" id="btn-main">Connect Hardware</button>
                <div id="demo-disclaimer" class="disclaimer" style="opacity:0;">* Demo Mode: Simulating sensor data stream.</div>
                <div style="margin-top: 30px;">
                    <h2>Live Vitals</h2>
                    <div class="card-row">
                        <div class="card" id="card-bpm">
                            <h3>Heart Rate</h3>
                            <div class="value"><span id="dash-bpm">--</span></div>
                            <small>BPM</small>
                        </div>
                        <div class="card" id="card-spo2">
                            <h3>Oxygen</h3>
                            <div class="value"><span id="dash-spo2">--</span></div>
                            <small>%</small>
                        </div>
                        <div class="card" id="card-temp">
                            <h3>Temp</h3>
                            <div class="value"><span id="dash-temp">--</span></div>
                            <small>Â°C</small>
                        </div>
                    </div>
                    <div class="ai-panel" id="dashboard-ai-box">
                        <i class="fas fa-robot"></i> <b>AI Insight:</b> System standby. Connect hardware to begin analysis.
                    </div>
                </div>
            </div>

            <div id="page-bio" class="page-section">
                <h1>Bio-Metrics Detail</h1>
                <div class="chart-box" style="height: 250px; margin-bottom: 20px;">
                    <canvas id="chart-bpm-detail"></canvas>
                </div>
                <div class="charts-grid">
                    <div class="chart-box"><canvas id="chart-spo2-detail"></canvas></div>
                    <div class="chart-box"><canvas id="chart-temp-detail"></canvas></div>
                </div>
            </div>

            <div id="page-analytics" class="page-section">
                <h1>Historical Analytics</h1>
                <div class="charts-grid">
                    <div class="chart-box"><h4>Sleep Quality</h4><canvas id="chart-sleep"></canvas></div>
                    <div class="chart-box"><h4>Stress Levels</h4><canvas id="chart-stress"></canvas></div>
                </div>
                <div class="chart-box" style="margin-top:20px;"><h4>Weight Tracker</h4><canvas id="chart-weight"></canvas></div>
            </div>

            <div id="page-ai" class="page-section">
                <h1>AI Diagnostics</h1>
                <div class="ai-panel" style="background: var(--surface); border: 1px solid var(--border);">
                    <ul class="ai-list" id="full-ai-list"><li>Waiting for data stream...</li></ul>
                </div>
            </div>

            <div id="page-profile" class="page-section">
                <h1>User Profile</h1>
                <div class="form-grid">
                    <div class="input-group"><label>Full Name</label><input type="text" value="Demo User"></div>
                    <div class="input-group"><label>Age</label><input type="number" value="28"></div>
                    <div class="input-group"><label>Height (cm)</label><input type="number" value="175"></div>
                    <div class="input-group"><label>Weight (kg)</label><input type="number" value="70"></div>
                </div>
                <button class="btn-connect" style="font-size:0.8rem;">Save Changes</button>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let state = { bpm: 0, spo2: 0, temp: 0, healthScore: 100 };
        let mouse = { x: 0, y: 0, targetX: 0, targetY: 0, normalizedX: 0, normalizedY: 0 };
        
        let robot, eyeL, eyeR, head, neck, pupilL, pupilR;
        let isDemoActive = false;
        let simInterval;
        
        // Animation system variables
        let mixer = null;
        let animationActions = {};
        let currentAnimation = null;
        let currentAnimationName = null;
        let headFollowingEnabled = true;
        let forcedAnimationMode = false;
        let currentForcedAnimation = null;
        
        // Bone references for eye control
        let eyeLBone = null;
        let eyeRBone = null;
        let headBone = null;
        let neckBone = null;
        
        // Mouth morph targets
        let mouthMesh = null;
        let happyMouthIndex = -1;
        let sadMouthIndex = -1;
        
        // Material references - using arrays to handle multiple materials
        let bodyMaterials = [];
        let eyeMaterials = [];
        let jointMaterials = [];
        let tealMaterials = [];
        let redMaterials = [];
        
        // Material state variables
        let currentMaterialState = 'healthy';
        let materialTransitionSpeed = 0.1;
        
        // Define material color states for different animations
        const materialStates = {
            idle_healthy: {
                bodyColor: new THREE.Color(0xD4D4D4),    // Silver
                eyeColor: new THREE.Color(0x00F0FF),     // Blue
                redColor: new THREE.Color(0x00F0FF),     // Blue
                jointColor: new THREE.Color(0x333333),   // Dark Grey
                tealColor: new THREE.Color(0x00F0FF),    // Teal
                stateName: 'Healthy (Silver)',
                stateColor: '#D4D4D4'
            },
            idle_stressed: {
                bodyColor: new THREE.Color(0xA0522D),    // Light Rust (30% rust mix)
                eyeColor: new THREE.Color(0xFFAA00),     // Orange
                redColor: new THREE.Color(0xFFAA00),     // Orange
                jointColor: new THREE.Color(0x2A2A2A),   // Slightly darker
                tealColor: new THREE.Color(0xFFAA00),    // Orange
                stateName: 'Stressed (Light Rust)',
                stateColor: '#A0522D'
            },
            idle_critical: {
                bodyColor: new THREE.Color(0x8B4513),    // Rust Brown (60% rust mix)
                eyeColor: new THREE.Color(0xFF0000),     // Red
                redColor: new THREE.Color(0xFF0000),     // Red
                jointColor: new THREE.Color(0x1A1A1A),   // Very dark
                tealColor: new THREE.Color(0xFF0000),    // Red
                stateName: 'Critical (Rust Brown)',
                stateColor: '#8B4513'
            },
            idle_alert: {
                bodyColor: new THREE.Color(0x5C2C06),    // Dark Rust (Black/Rust mix)
                eyeColor: new THREE.Color(0x000000),     // Black/Off
                redColor: new THREE.Color(0x000000),     // Black/Off
                jointColor: new THREE.Color(0x000000),   // Black
                tealColor: new THREE.Color(0x8B0000),    // Dark Red
                stateName: 'Alert (Dark Rust)',
                stateColor: '#5C2C06'
            }
        };
        
        let clock = new THREE.Clock();
        let container, customCursor, charts = {};
        let camera, renderer, scene;

        // Global functions
        function updateAnimationBasedOnHealth(healthScore, force = false) {
            if (!mixer || Object.keys(animationActions).length === 0) {
                return;
            }
            
            // If forced mode is active, don't change based on health
            if (forcedAnimationMode && currentForcedAnimation) {
                return;
            }
            
            let targetAnimationName = "";
            
            if (healthScore > 80) {
                targetAnimationName = "idle_healthy";
            } else if (healthScore > 50) {
                targetAnimationName = "idle_stressed";
            } else if (healthScore > 20) {
                targetAnimationName = "idle_critical";
            } else {
                targetAnimationName = "idle_alert";
            }
            
            const targetAnimation = animationActions[targetAnimationName];
            
            if (!targetAnimation) {
                console.warn(`Animation "${targetAnimationName}" not found`);
                return;
            }
            
            if (!force && currentAnimationName === targetAnimationName) {
                return;
            }
            
            console.log(`Switching to animation: ${targetAnimationName}`);
            
            if (currentAnimation) {
                currentAnimation.fadeOut(0.5);
            }
            
            targetAnimation.reset();
            targetAnimation.fadeIn(0.5);
            targetAnimation.play();
            
            currentAnimation = targetAnimation;
            currentAnimationName = targetAnimationName;
            
            // Only disable head following for alert animation
            headFollowingEnabled = (targetAnimationName !== "idle_alert");
            
            updateMouthShape(healthScore);
            updateMaterialState(targetAnimationName);
            updateAnimationStatus();
        }

        function forceAnimation(animName) {
            if (!mixer || !animationActions[animName]) {
                console.error(`Animation "${animName}" not available`);
                return;
            }
            
            forcedAnimationMode = true;
            currentForcedAnimation = animName;
            
            if (currentAnimation) {
                currentAnimation.fadeOut(0.3);
            }
            
            animationActions[animName].reset();
            animationActions[animName].fadeIn(0.3);
            animationActions[animName].play();
            
            currentAnimation = animationActions[animName];
            currentAnimationName = animName;
            
            // Disable head following for alert animation
            headFollowingEnabled = (animName !== "idle_alert");
            
            // Update materials
            updateMaterialState(animName);
            
            // Update UI
            updateAnimationStatus();
            updateForceButtonStates();
        }

        function resetToSensorMode() {
            forcedAnimationMode = false;
            currentForcedAnimation = null;
            updateAnimationBasedOnHealth(state.healthScore, true);
            updateForceButtonStates();
        }

        function updateMouthShape(healthScore) {
            if (!mouthMesh || happyMouthIndex === -1 || sadMouthIndex === -1) {
                return;
            }
            
            if (mouthMesh.morphTargetInfluences) {
                // Reset all morph targets
                for (let i = 0; i < mouthMesh.morphTargetInfluences.length; i++) {
                    mouthMesh.morphTargetInfluences[i] = 0;
                }
                
                // Apply appropriate mouth shape based on health
                if (healthScore >= 80) {
                    // Healthy: Full happy smile
                    mouthMesh.morphTargetInfluences[happyMouthIndex] = 1.0;
                } else if (healthScore >= 50) {
                    // Stressed: Slight smile (30%)
                    mouthMesh.morphTargetInfluences[happyMouthIndex] = 0.3;
                } else if (healthScore >= 20) {
                    // Critical: Neutral mouth
                    mouthMesh.morphTargetInfluences[happyMouthIndex] = 0;
                } else {
                    // Alert: Sad mouth
                    mouthMesh.morphTargetInfluences[sadMouthIndex] = 1.0;
                }
            }
        }

        function updateMaterialState(animationName) {
            if (!materialStates[animationName]) {
                console.warn(`No material state defined for animation: ${animationName}`);
                return;
            }
            
            currentMaterialState = animationName;
            
            // Update UI indicator
            const state = materialStates[animationName];
            const stateColorEl = document.getElementById('materialStateColor');
            const stateTextEl = document.getElementById('materialStateText');
            
            if (stateColorEl) stateColorEl.style.background = state.stateColor;
            if (stateTextEl) stateTextEl.textContent = state.stateName;
        }

        function updateMaterials() {
            if (!materialStates[currentMaterialState]) return;
            
            const targetState = materialStates[currentMaterialState];
            
            // Smoothly transition body materials
            bodyMaterials.forEach(mat => {
                if (mat && mat.color) {
                    mat.color.lerp(targetState.bodyColor, materialTransitionSpeed);
                    
                    // Add rust effect with roughness
                    if (mat.roughness !== undefined) {
                        if (currentMaterialState === 'idle_healthy') {
                            mat.roughness = 0.3; // Smooth metallic
                        } else if (currentMaterialState === 'idle_stressed') {
                            mat.roughness = 0.6; // Slightly rough
                        } else if (currentMaterialState === 'idle_critical') {
                            mat.roughness = 0.8; // Rough rust
                        } else if (currentMaterialState === 'idle_alert') {
                            mat.roughness = 0.9; // Very rough/damaged
                        }
                    }
                }
            });
            
            // Update eye materials (pupils)
            eyeMaterials.forEach(mat => {
                if (mat && mat.color) {
                    mat.color.lerp(targetState.eyeColor, materialTransitionSpeed * 2);
                    
                    // Adjust emission for eye glow
                    if (mat.emissive) {
                        if (currentMaterialState === 'idle_alert') {
                            // Turn off emission for alert state
                            mat.emissive.lerp(new THREE.Color(0x000000), materialTransitionSpeed * 2);
                        } else {
                            mat.emissive.lerp(targetState.eyeColor, materialTransitionSpeed * 2);
                        }
                    }
                }
            });
            
            // Update joint materials
            jointMaterials.forEach(mat => {
                if (mat && mat.color) {
                    mat.color.lerp(targetState.jointColor, materialTransitionSpeed);
                }
            });
            
            // Update teal accent materials
            tealMaterials.forEach(mat => {
                if (mat && mat.color) {
                    mat.color.lerp(targetState.tealColor, materialTransitionSpeed * 2);
                }
            });
            
            // Update red accent materials (antenna tips)
            redMaterials.forEach(mat => {
                if (mat && mat.color) {
                    mat.color.lerp(targetState.redColor, materialTransitionSpeed * 2);
                    
                    // Adjust emission for red parts
                    if (mat.emissive) {
                        if (currentMaterialState === 'idle_alert') {
                            // Turn off emission for alert state
                            mat.emissive.lerp(new THREE.Color(0x000000), materialTransitionSpeed * 2);
                        } else {
                            mat.emissive.lerp(targetState.redColor, materialTransitionSpeed * 2);
                        }
                    }
                }
            });
        }

        // Helper function to find materials by name or color
        function findMaterials(robot) {
            if (!robot) return;
            
            robot.traverse((child) => {
                if (child.isMesh) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    
                    materials.forEach(mat => {
                        if (!mat) return;
                        
                        // Log material for debugging
                        console.log("Found material:", mat.name, "on mesh:", child.name);
                        
                        // Check by name first
                        if (mat.name) {
                            const name = mat.name.toLowerCase();
                            if (name.includes('body') || name.includes('silver') || name.includes('main')) {
                                if (!bodyMaterials.includes(mat)) bodyMaterials.push(mat);
                            } else if (name.includes('eye') && !name.includes('socket')) {
                                if (!eyeMaterials.includes(mat)) eyeMaterials.push(mat);
                            } else if (name.includes('joint') || name.includes('dark')) {
                                if (!jointMaterials.includes(mat)) jointMaterials.push(mat);
                            } else if (name.includes('teal') || name.includes('cyan')) {
                                if (!tealMaterials.includes(mat)) tealMaterials.push(mat);
                            } else if (name.includes('red')) {
                                if (!redMaterials.includes(mat)) redMaterials.push(mat);
                            }
                        }
                        
                        // Also check by color for fallback
                        if (mat.color) {
                            const colorHex = mat.color.getHex();
                            // Check for silver/metallic colors
                            if (colorHex === 0xcccccc || colorHex === 0xd4d4d4 || colorHex === 0xaaaaaa) {
                                if (!bodyMaterials.includes(mat)) bodyMaterials.push(mat);
                            }
                            // Check for blue/teal colors
                            else if (colorHex === 0x00f0ff || colorHex === 0x00ffff || colorHex === 0x0088ff) {
                                if (!eyeMaterials.includes(mat) && !tealMaterials.includes(mat)) {
                                    // Try to determine if it's eye or teal by mesh name
                                    if (child.name.includes('Pupil') || child.name.includes('Eye')) {
                                        if (!eyeMaterials.includes(mat)) eyeMaterials.push(mat);
                                    } else {
                                        if (!tealMaterials.includes(mat)) tealMaterials.push(mat);
                                    }
                                }
                            }
                            // Check for red colors
                            else if (colorHex === 0xff0000 || colorHex === 0xff4444) {
                                if (!redMaterials.includes(mat)) redMaterials.push(mat);
                            }
                        }
                    });
                }
            });
            
            console.log("Found materials:");
            console.log("Body materials:", bodyMaterials.length);
            console.log("Eye materials:", eyeMaterials.length);
            console.log("Joint materials:", jointMaterials.length);
            console.log("Teal materials:", tealMaterials.length);
            console.log("Red materials:", redMaterials.length);
        }

        function updateAnimationStatus() {
            const statusEl = document.getElementById('currentAnimationStatus');
            if (statusEl) {
                statusEl.textContent = currentAnimationName || '--';
                if (forcedAnimationMode) {
                    statusEl.innerHTML = `<span style="color: var(--primary)">${currentAnimationName} (Forced)</span>`;
                } else {
                    statusEl.innerHTML = `<span style="color: var(--success)">${currentAnimationName} (Sensor)</span>`;
                }
            }
        }

        function updateForceButtonStates() {
            document.querySelectorAll('.force-btn').forEach(btn => {
                if (btn.dataset.anim === currentForcedAnimation) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            container = document.getElementById('three-canvas-container');
            customCursor = document.getElementById('customCursor');

            if (window.innerWidth > 900) {
                customCursor.style.display = 'block';
            }

            // Setup animation mode selector
            const animationModeSelect = document.getElementById('animationMode');
            const forcedControls = document.getElementById('forcedControls');
            
            animationModeSelect.addEventListener('change', (e) => {
                if (e.target.value === 'forced') {
                    forcedControls.style.display = 'block';
                    if (!currentForcedAnimation) {
                        forceAnimation('idle_healthy');
                    }
                } else {
                    forcedControls.style.display = 'none';
                    resetToSensorMode();
                }
            });
            
            // Setup force animation buttons
            document.querySelectorAll('.force-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    forceAnimation(btn.dataset.anim);
                });
            });

            // --- INIT ---
            initThreeJS();
            initCharts();
            animate();

            // --- 1. THREE.JS SETUP WITH ANIMATIONS ---
            function initThreeJS() {
                scene = new THREE.Scene();
                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.shadowMap.enabled = true;
                container.appendChild(renderer.domElement);

                // Camera
                camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
                
                // Adjust camera
                adjustCameraPosition();

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const keyLight = new THREE.DirectionalLight(0xffffff, 1.5);
                keyLight.position.set(5, 5, 5);
                keyLight.castShadow = true;
                scene.add(keyLight);
                const backLight = new THREE.SpotLight(0x00F0FF, 5);
                backLight.position.set(-5, 5, -5);
                scene.add(backLight);

                // --- LOAD ROBOT WITH ANIMATIONS ---
                const loader = new THREE.GLTFLoader();

                loader.load('Robot.glb', 
                    (gltf) => {
                        console.log("Robot GLTF loaded successfully");
                        robot = gltf.scene;
                        scene.add(robot);
                        robot.position.y = -1.0;
                        robot.rotation.y = Math.PI;

                        // Find bones for animation control
                        robot.traverse((child) => {
                            if (child.isBone) {
                                console.log("Found bone:", child.name);
                                
                                // Look for eye bones (from your Blender hierarchy)
                                if (child.name.includes('Eye') && !child.name.includes('Pupil')) {
                                    if (child.name.includes('L') || child.name.includes('Left')) {
                                        eyeLBone = child;
                                        console.log("Found left eye bone:", child.name);
                                    }
                                    if (child.name.includes('R') || child.name.includes('Right')) {
                                        eyeRBone = child;
                                        console.log("Found right eye bone:", child.name);
                                    }
                                }
                                
                                // Look for head bone
                                if (child.name.includes('Head') && !child.name.includes('Tip')) {
                                    headBone = child;
                                    console.log("Found head bone:", child.name);
                                }
                                
                                // Look for neck bone
                                if (child.name.includes('Neck')) {
                                    neckBone = child;
                                    console.log("Found neck bone:", child.name);
                                }
                            }
                            
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Find pupils for color change
                                if (child.name.includes('Pupil_L')) {
                                    pupilL = child;
                                    console.log("Found left pupil:", child.name);
                                }
                                if (child.name.includes('Pupil_R')) {
                                    pupilR = child;
                                    console.log("Found right pupil:", child.name);
                                }
                                
                                // Find mouth mesh
                                if ((child.name.includes('Mouth') || child.name.includes('Head')) && child.morphTargetDictionary) {
                                    mouthMesh = child;
                                    console.log("Found mouth mesh:", child.name);
                                    
                                    const morphDict = child.morphTargetDictionary;
                                    for (const key in morphDict) {
                                        if (key.toLowerCase().includes('happy')) {
                                            happyMouthIndex = morphDict[key];
                                            console.log("Found happy morph at index:", happyMouthIndex);
                                        }
                                        if (key.toLowerCase().includes('sad')) {
                                            sadMouthIndex = morphDict[key];
                                            console.log("Found sad morph at index:", sadMouthIndex);
                                        }
                                    }
                                }
                            }
                        });

                        // Find and categorize materials
                        findMaterials(robot);

                        // Setup animation system
                        setupAnimations(gltf);
                        
                        // Start with healthy animation
                        updateAnimationBasedOnHealth(100, true);
                        updateAnimationStatus();
                        
                        // Initialize material state
                        updateMaterialState('idle_healthy');
                    },
                    (xhr) => {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                    (error) => {
                        console.error("GLB Load Failed:", error);
                        createProceduralRobot();
                    }
                );

                // --- HELPER: SETUP ANIMATIONS ---
                function setupAnimations(gltf) {
                    if (!gltf.animations || gltf.animations.length === 0) {
                        console.warn("No animations found in GLTF file");
                        return;
                    }

                    console.log("Found animations:", gltf.animations.map(a => a.name));
                    
                    // Create animation mixer
                    mixer = new THREE.AnimationMixer(robot);
                    
                    // Create actions for each animation clip
                    const animationClips = gltf.animations;
                    
                    // Find animations by name (case-insensitive)
                    animationActions = {
                        idle_healthy: null,
                        idle_stressed: null,
                        idle_critical: null,
                        idle_alert: null
                    };
                    
                    animationClips.forEach(clip => {
                        const name = clip.name.toLowerCase();
                        
                        if (name === 'idle_healthy' || name === 'idle_healthy') {
                            animationActions.idle_healthy = mixer.clipAction(clip);
                        } else if (name === 'idle_stressed') {
                            animationActions.idle_stressed = mixer.clipAction(clip);
                        } else if (name === 'idle_critical') {
                            animationActions.idle_critical = mixer.clipAction(clip);
                        } else if (name === 'idle_alert') {
                            animationActions.idle_alert = mixer.clipAction(clip);
                        }
                    });
                    
                    // If not found by exact name, try partial matching
                    if (!animationActions.idle_healthy) {
                        const healthyClip = animationClips.find(clip => 
                            clip.name.toLowerCase().includes('healthy') || 
                            clip.name.toLowerCase().includes('idle')
                        );
                        if (healthyClip) animationActions.idle_healthy = mixer.clipAction(healthyClip);
                    }
                    
                    if (!animationActions.idle_stressed) {
                        const stressedClip = animationClips.find(clip => 
                            clip.name.toLowerCase().includes('stressed')
                        );
                        if (stressedClip) animationActions.idle_stressed = mixer.clipAction(stressedClip);
                    }
                    
                    if (!animationActions.idle_critical) {
                        const criticalClip = animationClips.find(clip => 
                            clip.name.toLowerCase().includes('critical')
                        );
                        if (criticalClip) animationActions.idle_critical = mixer.clipAction(criticalClip);
                    }
                    
                    if (!animationActions.idle_alert) {
                        const alertClip = animationClips.find(clip => 
                            clip.name.toLowerCase().includes('alert')
                        );
                        if (alertClip) animationActions.idle_alert = mixer.clipAction(alertClip);
                    }
                    
                    // Configure all found animations
                    for (const key in animationActions) {
                        if (animationActions[key]) {
                            animationActions[key].setLoop(THREE.LoopRepeat);
                            animationActions[key].clampWhenFinished = false;
                            console.log(`Configured animation: ${key}`);
                        }
                    }
                    
                    // IMPORTANT: Stop the pupil animations if they exist
                    const pupilAnimations = animationClips.filter(clip => 
                        clip.name.toLowerCase().includes('pupil')
                    );
                    
                    pupilAnimations.forEach(clip => {
                        const action = mixer.clipAction(clip);
                        action.stop(); // Stop these animations so we can control pupils manually
                        console.log(`Stopped pupil animation: ${clip.name}`);
                    });
                }

                // --- HELPER: FALLBACK ROBOT ---
                function createProceduralRobot() {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({color: 0xcccccc});
                    const eyeMat = new THREE.MeshBasicMaterial({color: 0x00F0FF});
                    
                    head = new THREE.Group(); 
                    head.position.y = 1.0; 
                    group.add(head);
                    
                    const headMesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1, 1), mat);
                    head.add(headMesh);
                    head.name = "Head";
                    
                    eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
                    eyeL.name = "Eye_L";
                    eyeL.position.set(-0.3, 0.1, 0.5); 
                    head.add(eyeL);
                    
                    eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
                    eyeR.name = "Eye_R";
                    eyeR.position.set(0.3, 0.1, 0.5); 
                    head.add(eyeR);
                    
                    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 32), mat);
                    body.position.y = 0; 
                    group.add(body);
                    
                    scene.add(group);
                    robot = group;
                    robot.position.y = -1.0;
                    
                    // Set fallback materials
                    bodyMaterials.push(mat);
                    eyeMaterials.push(eyeMat);
                }

                // --- INPUT EVENTS FOR FULL SCREEN TRACKING ---
                function updateMousePosition(x, y) {
                    const viewportCenterX = window.innerWidth * 0.225;
                    const viewportCenterY = (window.innerHeight - 50) * 0.5 + 25;
                    
                    const offsetX = x - viewportCenterX;
                    const offsetY = viewportCenterY - y;
                    
                    mouse.normalizedX = THREE.MathUtils.clamp(offsetX / (window.innerWidth * 0.5), -1, 1);
                    mouse.normalizedY = THREE.MathUtils.clamp(offsetY / (window.innerHeight * 0.5), -1, 1);
                    
                    mouse.targetX = (x / window.innerWidth) * 2 - 1;
                    mouse.targetY = -(y / window.innerHeight) * 2 + 1;
                    
                    if (customCursor.style.display !== 'none') {
                        customCursor.style.left = `${x}px`;
                        customCursor.style.top = `${y}px`;
                    }
                }

                // MOUSE MOVEMENT on entire window
                document.addEventListener('mousemove', (e) => {
                    updateMousePosition(e.clientX, e.clientY);
                });

                // TOUCH MOVEMENT on entire window
                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        updateMousePosition(e.touches[0].clientX, e.touches[0].clientY);
                        e.preventDefault();
                    }
                }, { passive: false });

                container.addEventListener('mouseenter', () => {
                    if (window.innerWidth > 900) {
                        customCursor.style.transform = 'translate(-50%, -50%) scale(1.2)';
                        customCursor.style.borderColor = 'var(--primary)';
                    }
                });

                container.addEventListener('mouseleave', () => {
                    if (window.innerWidth > 900) {
                        customCursor.style.transform = 'translate(-50%, -50%) scale(1)';
                        customCursor.style.borderColor = 'var(--primary)';
                    }
                });

                // --- RESIZE HANDLER ---
                window.addEventListener('resize', () => {
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    adjustCameraPosition();
                    
                    if (window.innerWidth > 900) {
                        customCursor.style.display = 'block';
                        document.body.style.cursor = 'none';
                    } else {
                        customCursor.style.display = 'none';
                        document.body.style.cursor = 'auto';
                    }
                });

                // --- ANIMATION LOOP ---
                window.animate = function() {
                    requestAnimationFrame(animate);
                    const delta = clock.getDelta();

                    // Update animation mixer
                    if (mixer) {
                        mixer.update(delta);
                    }

                    // Smoothly interpolate mouse position
                    mouse.x += (mouse.normalizedX - mouse.x) * 0.15;
                    mouse.y += (mouse.normalizedY - mouse.y) * 0.15;

                    // Apply head and eye following if enabled
                    if (robot && headFollowingEnabled) {
                        // Calculate target rotations based on mouse position
                        const targetHeadRotationY = THREE.MathUtils.clamp(mouse.x * 0.5, -0.5, 0.5);
                        const targetHeadRotationX = THREE.MathUtils.clamp(mouse.y * 0.3, -0.3, 0.3);
                        
                        // Calculate eye rotations (eyes move more than head)
                        const targetEyeRotationY = THREE.MathUtils.clamp(mouse.x * 0.8, -0.8, 0.8);
                        const targetEyeRotationX = THREE.MathUtils.clamp(mouse.y * 0.5, -0.5, 0.5);
                        
                        // Apply rotation to head bone if found
                        if (headBone) {
                            headBone.rotation.y = THREE.MathUtils.lerp(headBone.rotation.y, targetHeadRotationY, 0.1);
                            headBone.rotation.x = THREE.MathUtils.lerp(headBone.rotation.x, targetHeadRotationX, 0.1);
                        }
                        
                        // Apply rotation to neck bone if found
                        if (neckBone) {
                            neckBone.rotation.y = THREE.MathUtils.lerp(neckBone.rotation.y, targetHeadRotationY * 0.5, 0.08);
                            neckBone.rotation.x = THREE.MathUtils.lerp(neckBone.rotation.x, targetHeadRotationX * 0.5, 0.08);
                        }
                        
                        // Apply rotation to eye bones if found
                        if (eyeLBone) {
                            eyeLBone.rotation.y = THREE.MathUtils.lerp(eyeLBone.rotation.y, targetEyeRotationY, 0.15);
                            eyeLBone.rotation.x = THREE.MathUtils.lerp(eyeLBone.rotation.x, targetEyeRotationX, 0.15);
                        }
                        
                        if (eyeRBone) {
                            eyeRBone.rotation.y = THREE.MathUtils.lerp(eyeRBone.rotation.y, targetEyeRotationY, 0.15);
                            eyeRBone.rotation.x = THREE.MathUtils.lerp(eyeRBone.rotation.x, targetEyeRotationX, 0.15);
                        }
                        
                        // If we don't have eye bones, try to rotate the pupil meshes directly
                        if (!eyeLBone && pupilL) {
                            pupilL.rotation.y = THREE.MathUtils.lerp(pupilL.rotation.y, targetEyeRotationY, 0.15);
                            pupilL.rotation.x = THREE.MathUtils.lerp(pupilL.rotation.x, targetEyeRotationX, 0.15);
                        }
                        
                        if (!eyeRBone && pupilR) {
                            pupilR.rotation.y = THREE.MathUtils.lerp(pupilR.rotation.y, targetEyeRotationY, 0.15);
                            pupilR.rotation.x = THREE.MathUtils.lerp(pupilR.rotation.x, targetEyeRotationX, 0.15);
                        }
                    }
                    
                    // Update materials with smooth transitions
                    updateMaterials();
                    
                    renderer.render(scene, camera);
                }
            }

            // --- FUNCTION: Adjust Camera for Mobile ---
            function adjustCameraPosition() {
                if (!camera) return;
                const aspect = container.clientWidth / container.clientHeight;
                
                if (window.innerWidth < 900) {
                    const dist = aspect < 0.6 ? 9 : 7; 
                    camera.position.set(0, 0, dist);
                    camera.lookAt(0, -0.5, 0);
                } else {
                    camera.position.set(0, 0.5, 5);
                    camera.lookAt(0, 0, 0);
                }
            }

            // --- 2. DASHBOARD LOGIC ---
            window.navTo = function(pageId) {
                document.querySelectorAll('.list-item a').forEach(el => el.classList.remove('active'));
                const link = document.getElementById('nav-' + pageId);
                if(link) link.classList.add('active');
                document.querySelectorAll('.page-section').forEach(el => el.classList.remove('active'));
                document.getElementById('page-' + pageId).classList.add('active');
            }

            // --- 3. DEMO LOGIC ---
            window.toggleDemoMode = function() {
                const btn = document.getElementById('btn-main');
                const hwText = document.getElementById('hw-text');
                const hwDot = document.getElementById('hw-dot');
                const disclaimer = document.getElementById('demo-disclaimer');

                isDemoActive = !isDemoActive;

                if (isDemoActive) {
                    btn.innerText = "Hardware Connected";
                    btn.style.background = "var(--success)";
                    btn.style.color = "#fff";
                    hwText.innerText = "ONLINE"; hwText.style.color = "var(--success)";
                    hwDot.style.background = "var(--success)"; hwDot.style.boxShadow = "0 0 10px var(--success)";
                    disclaimer.style.opacity = 1;
                    simInterval = setInterval(runSimulationStep, 2000);
                    runSimulationStep(); 
                } else {
                    clearInterval(simInterval);
                    btn.innerText = "Connect Hardware";
                    btn.style.background = "var(--primary)";
                    btn.style.color = "#000";
                    hwText.innerText = "STANDBY"; hwText.style.color = "#888";
                    hwDot.style.background = "#555"; hwDot.style.boxShadow = "none";
                    disclaimer.style.opacity = 0;
                    resetData();
                    
                    // When simulation turns off, set health to 100 and play idle_healthy
                    state.healthScore = 100;
                    updateUI();
                    resetToSensorMode();
                }
            };

            function runSimulationStep() {
                const bpm = Math.floor(Math.random() * (120 - 60) + 60);
                const spo2 = Math.floor(Math.random() * (100 - 94) + 94);
                const temp = (Math.random() * (37.5 - 36.2) + 36.2).toFixed(1);
                state.bpm = bpm; state.spo2 = spo2; state.temp = temp;
                let score = 100;
                if(bpm > 100 || bpm < 50) score -= 20;
                if(spo2 < 95) score -= (95 - spo2) * 5;
                state.healthScore = Math.max(0, score);
                updateUI();
                updateCharts(bpm, spo2, temp);
                generateAIAnalysis(state.healthScore, bpm, spo2);
                updateRobotAppearance(state.healthScore);
                
                // Update animation based on new health score (unless forced mode)
                if (!forcedAnimationMode) {
                    updateAnimationBasedOnHealth(state.healthScore);
                }
            }

            function updateUI() {
                document.getElementById('dash-bpm').innerText = state.bpm;
                document.getElementById('dash-spo2').innerText = state.spo2;
                document.getElementById('dash-temp').innerText = state.temp;
                document.getElementById('val-health').innerText = state.healthScore + "%";
                const hVal = document.getElementById('val-health');
                if(state.healthScore > 80) hVal.style.color = "var(--primary)";
                else if (state.healthScore > 50) hVal.style.color = "var(--warning)";
                else hVal.style.color = "var(--danger)";
            }
            
            function resetData() {
                document.getElementById('dash-bpm').innerText = "--";
                document.getElementById('dash-spo2').innerText = "--";
                document.getElementById('dash-temp').innerText = "--";
                document.getElementById('val-health').innerText = "--";
            }

            function updateRobotAppearance(score) {
                // Only update the cursor color
                if (window.innerWidth > 900) {
                    if (score < 50) customCursor.style.borderColor = 'var(--danger)';
                    else if (score < 80) customCursor.style.borderColor = 'var(--warning)';
                    else customCursor.style.borderColor = 'var(--primary)';
                }
            }

            // --- 4. CHARTS & AI ---
            function generateAIAnalysis(score, bpm, spo2) {
                const aiBox = document.getElementById('dashboard-ai-box');
                const aiList = document.getElementById('full-ai-list');
                let mainMsg = ""; let details = [];
                if (score > 85) {
                    mainMsg = `<i class="fas fa-check-circle"></i> <b>OPTIMAL:</b> User is in peak cognitive condition.`;
                    details = ["Heart rate variability is stable.", "Oxygen saturation indicates good lung efficiency.", "Recommendation: Maintain current activity levels."];
                    aiBox.style.borderColor = "var(--success)"; aiBox.style.background = "rgba(16, 185, 129, 0.05)";
                } else if (score > 60) {
                    mainMsg = `<i class="fas fa-exclamation-triangle"></i> <b>WARNING:</b> Mild stress detected.`;
                    details = ["Elevated heart rate suggests physical or mental load.", "Recommendation: Take a 5-minute breathing break."];
                    aiBox.style.borderColor = "var(--warning)"; aiBox.style.background = "rgba(245, 158, 11, 0.05)";
                } else {
                    mainMsg = `<i class="fas fa-skull-crossbones"></i> <b>CRITICAL:</b> Vital signs indicate distress.`;
                    details = ["Tachycardia detected.", "Oxygen levels suboptimal.", "Recommendation: Cease activity immediately."];
                    aiBox.style.borderColor = "var(--danger)"; aiBox.style.background = "rgba(239, 68, 68, 0.05)";
                }
                aiBox.innerHTML = mainMsg;
                if(aiList) {
                    aiList.innerHTML = "";
                    details.forEach(txt => { const li = document.createElement('li'); li.innerHTML = `<i class="fas fa-angle-right" style="color:#555"></i> ${txt}`; aiList.appendChild(li); });
                }
            }

            function initCharts() {
                const commonOptions = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: false }, y: { grid: { color: '#333' } } }, elements: { point: { radius: 0 } }, animation: false };
                charts.bpm = new Chart(document.getElementById('chart-bpm-detail'), { type: 'line', data: { labels: Array(20).fill(''), datasets: [{ data: Array(20).fill(70), borderColor: '#00F0FF', tension: 0.4 }] }, options: { ...commonOptions, plugins: { title: { display: true, text: 'Real-time Heart Rate' } } } });
                charts.spo2 = new Chart(document.getElementById('chart-spo2-detail'), { type: 'line', data: { labels: Array(20).fill(''), datasets: [{ data: Array(20).fill(98), borderColor: '#10b981', tension: 0.4 }] }, options: { ...commonOptions, plugins: { title: { display: true, text: 'Real-time SpO2' } } } });
                charts.temp = new Chart(document.getElementById('chart-temp-detail'), { type: 'line', data: { labels: Array(20).fill(''), datasets: [{ data: Array(20).fill(36.5), borderColor: '#f59e0b', tension: 0.4 }] }, options: { ...commonOptions, plugins: { title: { display: true, text: 'Real-time Temperature' } } } });
                
                if(document.getElementById('chart-sleep')) new Chart(document.getElementById('chart-sleep'), { type: 'bar', data: { labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'], datasets: [{ label: 'Hours', data: [6.5, 7.0, 5.5, 8.0, 7.5, 9.0, 8.5], backgroundColor: '#7c3aed', borderRadius: 4 }] }, options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { grid: { color: '#333' } } } } });
                if(document.getElementById('chart-stress')) new Chart(document.getElementById('chart-stress'), { type: 'line', data: { labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'], datasets: [{ data: [20, 45, 30, 80, 55, 20, 15], borderColor: '#ef4444', tension: 0.3, fill: true, backgroundColor: 'rgba(239, 68, 68, 0.1)' }] }, options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { grid: { color: '#333' } } } } });
                if(document.getElementById('chart-weight')) new Chart(document.getElementById('chart-weight'), { type: 'line', data: { labels: ['Wk1', 'Wk2', 'Wk3', 'Wk4'], datasets: [{ data: [72, 71.5, 71.0, 70.8], borderColor: '#00F0FF', tension: 0.2 }] }, options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { grid: { color: '#333' } } } } });
            }

            function updateCharts(bpm, spo2, temp) {
                [charts.bpm, charts.spo2, charts.temp].forEach((chart, i) => { if(chart) { const val = [bpm, spo2, temp][i]; const d = chart.data.datasets[0].data; d.shift(); d.push(val); chart.update(); } });
            }
        });
    </script>
</body>
</html>